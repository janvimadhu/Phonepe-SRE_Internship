---
# - debug:
#     msg: "{{ hostvars[inventory_hostname]['ansible_default_ipv4']['address'] }}"

# - debug:
#     msg: "[{{ groups[es] | map('extract', hostvars, 'ansible_host') |  list | join(',') }}]"

# - debug:
#     msg: "[{{ play_hosts | map('extract', hostvars, 'ansible_host') |  list | join(',') }}]"

- include_tasks: setup-Debian.yml
  when: ansible_os_family == 'Debian'

- name: Run when data disk is present
  block:
    - name: find the disks with partitions
      shell: lsblk -ln -o NAME,TYPE | grep disk | awk '{print $1}' | xargs -i bash -c "ls /dev/ | grep {} | grep -E {}[0-9] | sed 's/[0-9]//g'" | uniq
      args:
        executable: /bin/bash
      register: cmd1
      ignore_errors: yes

    - name: find all disks
      shell: lsblk -ln -o NAME,TYPE | grep disk | awk '{print $1}'
      args:
        executable: /bin/bash
      register: cmd2
      ignore_errors: yes

    - name: find the new disk
      set_fact:
        difference: "{{ (cmd2.stdout_lines | difference(cmd1.stdout_lines)) | first }}"

    - name: set the new disk path
      set_fact:
        add_disk_name: "/dev/{{ difference }}"

    - name: check pvdisplay
      shell: pvdisplay
      register: pvdisplay_output
    
    - include_tasks: disk-partitioning.yml
      when: pvdisplay_output.stdout == ""

  when: 'is_data_disk_present == "true"'

# - name: check if disk exist
#   shell: ls /dev/sd*
#   register: dist_status

# - include_tasks: disk-partitioning.yml
#   when: add_disk_name in dist_status.stdout

- name: Install Elasticsearch.
  package:
    name: elasticsearch={{ elasticsearch_specific_version }}
    state: "{{ elasticsearch_package_state }}"

- name: changing permission
  become: yes
  file:
    path: "{{ item }}"
    state: directory
    recurse: yes
    owner: root
    group: elasticsearch
    mode: "0775"
  loop:
    - "{{ elasticsearch_source_directory }}"

- name: Configure Elasticsearch.
  template:
    src: "etc/elasticsearch/{{ item }}.j2"
    dest: "/etc/elasticsearch/{{ item }}"
    owner: root
    group: elasticsearch
    mode: 0660
  with_items:
    - elasticsearch.yml
    - jvm.options
  # notify: restart elasticsearch

- name: Configure Elasticsearch as a service
  template:
    src: "{{ item }}.j2"
    dest: "/{{ item }}"
    owner: root
    group: elasticsearch
    mode: 0660
  with_items:
    - usr/lib/systemd/system/elasticsearch.service

- name: reload-daemon
  command: systemctl daemon-reload

- name: Check node status
  shell: curl -XGET -u elastic:password "http://{{ ansible_hostname }}:{{ elasticsearch_http_port }}/_cat/nodes" | awk '{ print $10 }'
  register: cluster_health
  environment:
    http_proxy: ""
  # failed_when: ansible_hostname in cluster_health.stdout_lines

# - debug: msg="{{ cluster_health.stdout_lines }}"

  # uri:
  #   url: http://{{ ansible_hostname }}:9200/_cluster/health?pretty
  #   url_username: elastic
  #   url_password: password
  #   method: GET
  #   force_basic_auth: yes
  #   status_code: 200
  #   # body_format: json
  #   # headers:
  #   #   Content-Type: "application/json"
  #   # use_proxy: no
  # register: cluster_health
  # environment:
  #   http_proxy: ""

# - debug: msg="{{ cluster_health.stdout_lines }}"  
#   when: 'ansible_hostname not in cluster_health.stdout'

# - name: Force a restart if configuration has changed.
#   meta: flush_handlers

- name: restart elasticsearch if node not in cluster
  throttle: 1
  service: name=elasticsearch state=restarted
  when: 'ansible_host not in cluster_health.stdout'

- name: Start Elasticsearch.
  service:
    name: elasticsearch
    state: "{{ elasticsearch_service_state }}"
    enabled: "{{ elasticsearch_service_enabled }}"
  delay: 5
  throttle: 1
  when: 'ansible_host not in cluster_health.stdout'

- name: Make sure Elasticsearch is running before proceeding.
  wait_for:
    host: "{{ elasticsearch_network_host }}"
    port: "{{ elasticsearch_http_port }}"
    delay: 3
    timeout: 300

#- include_tasks: es_monitoring.yml
